#!/ms/dist/python/PROJ/core/3.11.4-1/bin/python

import re
import os
import sys
import json
import time
import argparse
import app_base, app_dep
import concurrent.futures
from typing import List, Dict, Any


def login_mks_cluster(mks_cluster):
    print(f"Logging in to {mks_cluster}")
    command = ["/ms/dist/cloud/PROJ/unimatrix/prod/bin/unimatrix", "login", mks_cluster]
    login_raw = app_base.execute_command(command, 60)
    print(login_raw.stdout.decode("utf-8"))
    if login_raw.returncode != 0:
        err = login_raw.stderr.decode("utf-8").split("\n")
        for message in err:
            if "HTTP response body" in message:
                print(f"{message}")
    return bool("MKS login completed" in login_raw.stdout.decode("utf-8"))


def logout_mks_cluster(mks_cluster):
    print(f"Logging out from {mks_cluster}")
    command = ["/ms/dist/cloud/PROJ/unimatrix/prod/bin/unimatrix", "logout", mks_cluster]
    logout_raw = app_base.execute_command(command, 60)
    print(logout_raw.stdout.decode("utf-8"))
    if logout_raw.returncode != 0:
        err = logout_raw.stderr.decode("utf-8").split("\n")
        for message in err:
            if "HTTP response body" in message:
                print(f"{message}")
    return bool("MKS logout completed" in logout_raw.stdout.decode("utf-8"))


def get_deployments(namespace, cluster_context=None):
    deployments = []
    command = [
        "/ms/dist/cloud/PROJ/kubectl/prod/bin/kubectl",
        "get",
        "deployments",
        "-o",
        "json",
        "-n",
        namespace,
    ]
    
    # If we have a specific cluster context, use it
    if cluster_context:
        command.extend(["--context", cluster_context])

    deployments_raw = app_base.execute_command(command, 30)
    deployments_data = json.loads(deployments_raw.stdout.decode("utf-8"))
    for item in deployments_data["items"]:
        deployments.append(item["metadata"]["name"])
    return deployments


def get_pods(namespace, cluster_context=None):
    pod_result = []
    command = [
        "/ms/dist/cloud/PROJ/kubectl/prod/bin/kubectl",
        "get",
        "pods",
        "-n",
        namespace,
    ]
    
    # If we have a specific cluster context, use it
    if cluster_context:
        command.extend(["--context", cluster_context])

    pods = app_base.execute_command(command, 30)
    pods_raw = pods.stdout.decode("utf-8").split("\n")

    for element in pods_raw[1:]:  # Skip header row
        if element.strip():
            parts = element.split()
            if len(parts) >= 3:
                pod_name = parts[0]
                pod_status = parts[2]
                pod_result.append({"pod": pod_name, "status": pod_status})
    return pod_result


def get_deployment_status(namespace, cluster_context=None):
    print(f"Getting deployment status for {namespace} in context {cluster_context}")
    status = {}
    deployments = get_deployments(namespace, cluster_context)

    for deployment in deployments:
        command = [
            "/ms/dist/cloud/PROJ/kubectl/prod/bin/kubectl",
            "rollout",
            "status",
            "deployment",
            deployment,
            "-n",
            namespace,
        ]
        
        # If we have a specific cluster context, use it
        if cluster_context:
            command.extend(["--context", cluster_context])

        deployment_status_raw = app_base.execute_command(command, 60)
        deployment_status = deployment_status_raw.stdout.decode("utf-8").strip()
        status.update({deployment: deployment_status})
    
    return status


def restart_aapc(namespace, exclude_services, cluster_context=None):
    print(f"Restarting deployments in {namespace}, excluding {exclude_services}, context: {cluster_context}")
    deployments = get_deployments(namespace, cluster_context)
    restart_status = {}
    
    for deployment in deployments:
        if deployment in exclude_services:
            print(f"Skipping excluded service: {deployment}")
            continue
            
        command = [
            "/ms/dist/cloud/PROJ/kubectl/prod/bin/kubectl",
            "rollout",
            "restart",
            "deployment",
            deployment,
            "-n",
            namespace,
        ]
        
        # If we have a specific cluster context, use it
        if cluster_context:
            command.extend(["--context", cluster_context])

        restart_result = app_base.execute_command(command, 600)
        if restart_result.returncode == 0:
            print(f"Restart successful for {deployment}")
            restart_status[deployment] = True
        else:
            print(f"Restart failed for {deployment}")
            restart_status[deployment] = False
    
    return restart_status


def get_cluster_context(cluster_name):
    """Extract the context name from the cluster name"""
    # The context is typically the part before the first dot in the cluster name
    # For example: "app41.hz.k8s.na.ms.com" -> context might be "app41"
    return cluster_name.split('.')[0]


def process_cluster(cluster: str, config: Dict[str, Any]) -> List[Dict[str, str]]:
    """Process a single cluster: login, restart, get pod details, logout"""
    print(f"Processing cluster: {cluster}")
    pod_details = []
    
    try:
        # Step 1: Login to cluster
        if not login_mks_cluster(cluster):
            print(f"Failed to login to cluster {cluster}")
            return pod_details
        
        # Get the cluster context for kubectl commands
        cluster_context = get_cluster_context(cluster)
        
        # Step 2: Restart deployments if required
        if config.get('restart_required', 'False').lower() == 'true':
            restart_status = restart_aapc(
                config['deployment_id'], 
                config.get('exclude_services_restart', []),
                cluster_context
            )
            print(f"Restart status for {cluster}: {restart_status}")
            
            # Wait for the specified time
            wait_time = config.get('wait_time', 420)
            print(f"Waiting for {wait_time} seconds...")
            time.sleep(wait_time)
        
        # Step 3: Get pod details
        pod_details = get_pods(config['deployment_id'], cluster_context)
        for pod in pod_details:
            pod['cluster'] = cluster
        
        # Step 4: Logout from cluster
        logout_mks_cluster(cluster)
        
    except Exception as e:
        print(f"Error processing cluster {cluster}: {str(e)}")
    
    return pod_details


def send(html_text, sub, mails, sender):
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    from email.utils import formataddr
    from email.header import Header

    msg = MIMEMultipart("alternative")
    msg["From"] = formataddr(
        ((str(Header("Statement", "utf-8"))), "pmisrt-dev@morganstanley.com")
    )
    msg["To"] = mails
    msg["Subject"] = sub
    body = MIMEText(html_text, "html")
    msg.attach(body)

    server = smtplib.SMTP()
    server.connect("smtp-hub.ms.com")
    server.ehlo()
    server.sendmail(sender, mails.split(","), msg.as_string())
    server.close()


def report_conversion(pod_data):
    # Determine status flag
    status_flag = "RED" if any(item['status'] != "Running" for item in pod_data) else "GREEN"
    
    # Generate HTML content
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Deployment Report</title>
        <style>
            body {{
                font-family: Arial, sans-serif;
                background-color: #f9f9f9;
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
            }}
            .container {{
                width: 100%;
                margin: auto;
                background: #ffffff;
                box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
                border-radius: 8px;
                overflow: hidden;
            }}
            .header {{
                background-color: #4CAF50;
                color: white;
                text-align: center;
                padding: 20px;
                font-size: 20px;
            }}
            table {{
                width:100%;
                border-collapse: collapse;
                font-size: 14px;
            }}
            th, td {{
                padding: 8px;
                text-align: left;
                border: 1px solid #ddd;
            }}
            tr:hover {{
                background-color: #f1f1f1;
            }}
            th {{
                background-color: #f4f4f4;
            }}
        </style>
    </head>
    <body>
    <p>Dear Team,</p>
    <p>Please find the status of PNSRT's deployment services after restarting all POD instances.</p>

    <div class="container">
        <div class="header" style="background-color:{status_flag};">
            <h3>PNSRT Deployment's Restart Report</h3>
        </div>
        <table>
            <tr>
                <th>S.No</th>
                <th>Cluster</th>
                <th>Pod Name</th>
                <th>Pod Status</th>
            </tr>
    """
    
    # Add table rows
    for i, item in enumerate(pod_data):
        html_content += f"""
            <tr>
                <td>{i+1}</td>
                <td>{item.get('cluster', 'N/A')}</td>
                <td>{item.get('pod', 'N/A')}</td>
                <td>{item.get('status', 'N/A')}</td>
            </tr>
        """
    
    html_content += """
        </table>
    </div>
    <p>Thank you,</p>
    <p>PNSRT ASG</p>
    </body>
    </html>
    """
    
    return html_content, status_flag


def main():
    if len(sys.argv) < 2:
        print("Usage: python script.py <config_file_path>")
        sys.exit(1)
    
    # Load configuration from JSON file
    config_path = sys.argv[1]
    with open(config_path, 'r') as file:
        config = json.load(file)
    
    all_pod_status = []
    
    # Process clusters in parallel
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(config['clusters'])) as executor:
        # Submit all cluster processing tasks
        future_to_cluster = {
            executor.submit(process_cluster, cluster, config): cluster 
            for cluster in config['clusters']
        }
        
        # Collect results as they complete
        for future in concurrent.futures.as_completed(future_to_cluster):
            cluster = future_to_cluster[future]
            try:
                pod_details = future.result()
                all_pod_status.extend(pod_details)
                print(f"Completed processing for cluster: {cluster}")
            except Exception as e:
                print(f"Cluster {cluster} generated an exception: {str(e)}")
    
    # Generate and send report
    html_report, status_flag = report_conversion(all_pod_status)
    email_subject = f"{status_flag} {config['email']['subject']}"
    send(
        html_report, 
        email_subject, 
        config['email']['receiver'], 
        config['email']['sender']
    )
    
    print("All clusters processed successfully")


if __name__ == "__main__":
    main()
